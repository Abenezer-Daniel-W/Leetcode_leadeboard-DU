import EventEmitter from 'eventemitter3';
import { Fetcher } from '@fetch-impl/fetcher';

/**
 * Cache class
 */
declare class Cache {
    private _table;
    /**
     * Get an item from the cache.
     * @param key The key of the item.
     * @returns {any} The item, or null if it doesn't exist.
     */
    get(key: string): unknown;
    /**
     * Set an item in the cache.
     * @param key The key of the item.
     * @param value The value of the item.
     * @param expires The time in milliseconds until the item expires.
     */
    set(key: string, value: unknown, expires?: number): void;
    /**
     * Remove an item from the cache.
     * @param key The key of the item.
     */
    remove(key: string): void;
    /**
     * Clear the cache.
     */
    clear(): void;
    /**
     * Load the cache from a JSON string.
     * @param json A {@link CacheTable}-like JSON string.
     */
    load(json: string): void;
}
declare const cache: Cache;
declare const caches: {
    [key: string]: Cache;
};

interface QueryParams {
    category?: string;
    offset?: number;
    limit?: number;
    filters?: {
        difficulty?: 'EASY' | 'MEDIUM' | 'HARD';
        tags?: string[];
    };
}
interface LeetcodeProblem {
    title: string;
    difficulty: ProblemDifficulty;
    topicTags: TopicTag[];
    companyTagStats: OfficialCompanyTagStats | null;
    frequency: number;
    similarQuestions: SimilarQuestion[] | string;
    questionFrontendId: string;
    isPaidOnly: boolean;
    solution: LeetcodeSolution;
    questionId: string;
    likes: number;
    dislikes: number;
    stats: Stats | string;
    titleSlug: string;
}
interface LeetcodeSolution {
    url: string;
    paidOnly: boolean;
    hasVideoSolution: boolean;
}
interface DetailedProblem {
    allowDiscuss?: boolean;
    article?: Article;
    categoryTitle?: string;
    codeDefinition?: CodeDefinition[];
    codeSnippets?: CodeSnippet[];
    companyTagStats?: OfficialCompanyTagStats | null;
    content?: string;
    difficulty?: ProblemDifficulty;
    dislikes?: number;
    enableRunCode?: boolean;
    enableSubmit?: boolean;
    enableTestMode?: boolean;
    frequency?: number;
    hints?: string[];
    infoVerified?: boolean;
    interpretUrl?: string;
    isLiked?: true | null;
    isPaidOnly?: boolean;
    judgeType?: string;
    judgerAvailable?: boolean;
    langToValidPlayground?: Record<string, boolean>;
    libraryUrl?: string | null;
    likes?: number;
    metaData?: string;
    mysqlSchemas?: string[];
    nextChallengePairs?: NextChallengePair[] | null;
    note?: string | null;
    questionDetailUrl?: string;
    questionFrontendId?: string;
    questionId?: string;
    questionTitle?: string;
    questionTitleSlug?: string;
    questionType?: string;
    sampleTestCase?: string;
    sessionId?: string;
    similarQuestions?: SimilarQuestion[];
    solution?: OfficialSolution;
    stats?: Stats;
    status?: string | null;
    submitUrl?: string;
    title?: string;
    titleSlug?: string;
    topicTags?: TopicTag[];
    translatedContent?: string | null;
    translatedTitle?: string | null;
}
interface NextChallengePair {
    question_title: string;
    question_title_slug: string;
    difficulty: 'E' | 'M' | 'H';
}
interface CodeDefinition {
    value: string;
    text: string;
    defaultCode: string;
}
interface Article {
    id: number;
    url: string;
    topicId: number;
}
interface SimilarQuestion {
    title: string;
    titleSlug: string;
    difficulty: ProblemDifficulty;
    translatedTitle: string | null;
}
interface CompanyTagStat {
    company: string;
    frequency: number;
}
interface OfficialCompanyTagStats {
    [type: string]: {
        taggedByAdmin: boolean;
        name: string;
        slug: string;
        timesEncountered: number;
    }[];
}
interface Stats {
    totalAccepted: string;
    totalSubmission: string;
    totalAcceptedRaw: number;
    totalSubmissionRaw: number;
    acRate: string;
}
interface ProblemFieldDetails {
    title: string;
    property: keyof DetailedProblem;
    graphql: string;
    enable: boolean;
    private: boolean;
    isPremium: boolean;
    needParsing: boolean;
    needRequestChunking: boolean;
    problemsPerRequest: number;
}
interface AllCompanyTags {
    companyTags: CompanyTagDetail[];
}
interface MinimalCompanyTagDetail {
    name: string;
    questions: {
        questionFrontendId: string;
    }[];
}
interface TopicTagDetails {
    questionFrontendId: string;
    topicTags: {
        name: string;
    }[];
}
interface CompanyTagDetail {
    id: string;
    imgUrl: string;
    name: string;
    slug: string;
    questionCount: number;
    questionIds: number[];
    frequencies: string;
}
interface EasterEggStatus {
    isEasterEggCollected: boolean;
}
interface AllQuestionsCount {
    difficulty: string;
    count: number;
}
interface Contributions {
    points: number;
    questionCount: number;
    testcaseCount: number;
}
interface Profile$1 {
    realName: string;
    websites: string[];
    countryName: string | null;
    skillTags: string[];
    company: string | null;
    school: string | null;
    starRating: number;
    aboutMe: string;
    userAvatar: string;
    reputation: number;
    ranking: number;
}
interface AcSubmissionNum {
    difficulty: string;
    count: number;
    submissions: number;
}
interface TotalSubmissionNum {
    difficulty: string;
    count: number;
    submissions: number;
}
interface SubmitStats {
    acSubmissionNum: AcSubmissionNum[];
    totalSubmissionNum: TotalSubmissionNum[];
}
interface Badge {
    id: string;
    displayName: string;
    icon: string;
    creationDate?: string;
}
interface MatchedUser {
    username: string;
    socialAccounts: unknown;
    githubUrl: null;
    contributions: Contributions;
    profile: Profile$1;
    submissionCalendar: string;
    submitStats: SubmitStats;
    badges: Badge[];
    upcomingBadges: Badge[];
    activeBadge: Badge | null;
}
interface UserProfile {
    allQuestionsCount: AllQuestionsCount[];
    matchedUser: MatchedUser | null;
    recentSubmissionList: UserSubmission[] | null;
}
interface Contest {
    title: string;
    startTime: number;
}
interface ContestInfo {
    attended: boolean;
    trendDirection: string;
    problemsSolved: number;
    totalProblems: number;
    finishTimeInSeconds: number;
    rating: number;
    ranking: number;
    contest: Contest;
}
interface ContestRanking {
    attendedContestsCount: number;
    rating: number;
    globalRanking: number;
    totalParticipants: number;
    topPercentage: number;
    badge: null | {
        name: string;
    };
}
interface UserContestInfo {
    userContestRanking: ContestRanking;
    userContestRankingHistory: ContestInfo[];
}
interface TopicTag {
    name: string;
    slug: string;
    translatedName: string | null;
}
interface CodeSnippet {
    lang: string;
    langSlug: string;
    code: string;
}
interface CodeSnippet {
    lang: string;
    langSlug: string;
    code: string;
}
interface OfficialSolution {
    canSeeDetail: boolean;
    content: string | null;
    contentTypeId: string;
    id: string;
    rating: {
        average: string;
        count: number;
        id: string;
        userRating: {
            id: string;
            score: number;
        } | null;
    };
    title: string;
    url: string;
    paidOnly: boolean;
    hasVideoSolution: boolean;
    paidOnlyVideo: boolean;
}
interface OfficialSolution {
    id: string;
    canSeeDetail: boolean;
    paidOnly: boolean;
    hasVideoSolution: boolean;
    paidOnlyVideo: boolean;
}
interface ChallengeQuestion {
    id: string;
    date: string;
    incompleteChallengeCount: number;
    streakCount: number;
    type: string;
}
interface ChallengeQuestion {
    id: string;
    date: string;
    incompleteChallengeCount: number;
    streakCount: number;
    type: string;
}
type ProblemDifficulty = 'Easy' | 'Medium' | 'Hard';
interface Problem {
    questionId: string;
    questionFrontendId: string;
    boundTopicId: unknown;
    title: string;
    titleSlug: string;
    content: string;
    translatedTitle: string | null;
    translatedContent: string | null;
    isPaidOnly: boolean;
    difficulty: ProblemDifficulty;
    likes: number;
    dislikes: number;
    isLiked: boolean | null;
    similarQuestions: string;
    exampleTestcases: string;
    contributors: unknown[];
    topicTags: TopicTag[];
    companyTagStats: unknown;
    codeSnippets: CodeSnippet[];
    stats: string;
    hints: string[];
    solution: OfficialSolution;
    status: unknown;
    sampleTestCase: string;
    metaData: string;
    judgerAvailable: boolean;
    judgeType: string;
    mysqlSchemas: unknown[];
    enableRunCode: boolean;
    enableTestMode: boolean;
    enableDebugger: boolean;
    envInfo: string;
    libraryUrl: string | null;
    adminUrl: string | null;
    challengeQuestion: ChallengeQuestion;
    /** null if not logged in */
    note: string | null;
}
type SubmissionStatus = 'Accepted' | 'Wrong Answer' | 'Time Limit Exceeded' | 'Memory Limit Exceeded' | 'Output Limit Exceeded' | 'Compile Error' | 'Runtime Error';
interface UserSubmission {
    id: string;
    isPending: string;
    memory: string;
    runtime: string;
    time: string;
    timestamp: string;
    title: string;
    titleSlug: string;
    statusDisplay: SubmissionStatus;
    lang: string;
    url: string;
}
interface Submission {
    id: number;
    question_id: number;
    lang: string;
    lang_name: string;
    time: string;
    timestamp: number;
    status: number;
    status_display: SubmissionStatus;
    runtime: string;
    url: string;
    is_pending: boolean;
    title: string;
    memory: number;
    code: string;
    compare_result: string;
    title_slug: string;
    has_notes: boolean;
    flat_type: number;
}
interface SubmissionsDump {
    submissions_dump: Submission[];
    has_next: string;
    last_key: string;
}
interface Whoami {
    userId: number | null;
    username: string;
    avatar: string | null;
    isSignedIn: boolean;
    isMockUser: boolean;
    isPremium: boolean | null;
    isAdmin: boolean;
    isSuperuser: boolean;
    isTranslator: boolean;
    activeSessionId: string;
    checkedInToday: string;
    permissions: string[];
}
interface SubmissionDetail {
    id: number;
    problem_id: number;
    runtime: number;
    runtime_distribution: [number, number][];
    runtime_percentile: number;
    memory: number;
    memory_distribution: [number, number][];
    memory_percentile: number;
    code: string;
    details: {
        status_code: number;
        runtime: string;
        memory: string;
        total_correct: string;
        total_testcases: string;
        compare_result: string;
        input_formatted: string;
        input: string;
        expected_output: string;
        code_output: string;
        last_testcase: string;
    };
}
interface ProblemList {
    total: number;
    questions: {
        acRate: number;
        difficulty: 'Easy' | 'Medium' | 'Hard';
        freqBar: null;
        questionFrontendId: string;
        isFavor: boolean;
        isPaidOnly: boolean;
        status: string | null;
        title: string;
        titleSlug: string;
        topicTags: {
            name: string;
            id: string;
            slug: string;
        }[];
        hasSolution: boolean;
        hasVideoSolution: boolean;
    }[];
}
interface DailyChallenge {
    date: string;
    link: string;
    question: Problem;
}
interface List {
    name: string;
    slug: string;
}

interface CacheItem {
    /**
     * The key of the item.
     */
    key: string;
    /**
     * The value of the item.
     */
    value: unknown;
    /**
     * The expiration time of the item in milliseconds since the Unix epoch.
     */
    expires: number;
}
/**
 * A simple in-memory cache table.
 */
interface CacheTable {
    [key: string]: CacheItem;
}
interface ICredential {
    /**
     * The authentication session.
     */
    session?: string;
    /**
     * The csrf token.
     */
    csrf?: string;
}
interface LeetCodeGraphQLQuery {
    operationName?: string;
    variables?: {
        [key: string]: unknown;
    };
    query: string;
    headers?: {
        [key: string]: string;
    };
}
interface LeetCodeGraphQLResponse {
    data: UserProfile | UserSubmission[] | any;
}
interface QuestionOfList {
    difficulty: string;
    id: number;
    paidOnly: boolean;
    questionFrontendId: string;
    status: string;
    title: string;
    titleSlug: string;
    topicTags: Array<{
        title: string;
        slug: string;
    }>;
    isInMyFavorites: boolean;
    frequency: number | null;
    acRate: number | null;
    __typename: string;
}

declare class Credential$1 implements ICredential {
    /**
     * The authentication session.
     */
    session?: string;
    /**
     * The csrf token.
     */
    csrf?: string;
    constructor(data?: ICredential);
    /**
     * Init the credential with or without leetcode session cookie.
     * @param session
     * @returns
     */
    init(session?: string): Promise<this>;
}

type Release = (value: void | PromiseLike<void>) => void;
declare class Mutex extends EventEmitter {
    protected space: number;
    protected used: number;
    protected releases: Release[];
    constructor(space?: number);
    lock(): Promise<number>;
    unlock(): number;
    resize(space: number): number;
    full(): boolean;
    waiting(): number;
    emit(event: 'lock' | 'unlock' | 'all-clear'): boolean;
    emit(event: 'wait', { lock, release }: {
        lock: Promise<void>;
        release: Release;
    }): boolean;
    emit(event: string): boolean;
    on(event: 'lock' | 'unlock' | 'all-clear', listener: () => void): this;
    on(event: 'wait', listener: ({ lock, release }: {
        lock: Promise<void>;
        release: Release;
    }) => void): this;
    on(event: string, listener: (...args: unknown[]) => void): this;
    once(event: 'lock' | 'unlock' | 'all-clear', listener: () => void): this;
    once(event: 'wait', listener: ({ lock, release }: {
        lock: Promise<void>;
        release: Release;
    }) => void): this;
    once(event: string, listener: (...args: unknown[]) => void): this;
}
declare class RateLimiter extends Mutex {
    private time_mutex;
    private count;
    private last;
    private timer?;
    interval: number;
    constructor({ limit, interval, concurrent }?: {
        limit?: number | undefined;
        interval?: number | undefined;
        concurrent?: number | undefined;
    });
    lock(): Promise<number>;
    reset(): void;
    cleaner(): void;
    set limit(limit: number);
    emit(event: 'lock' | 'unlock' | 'all-clear'): boolean;
    emit(event: 'wait', { lock, release }: {
        lock: Promise<void>;
        release: Release;
    }): boolean;
    emit(event: 'time-lock' | 'time-unlock' | 'timer-reset'): boolean;
    emit(event: string): boolean;
    on(event: 'lock' | 'unlock' | 'all-clear', listener: () => void): this;
    on(event: 'wait', listener: ({ lock, release }: {
        lock: Promise<void>;
        release: Release;
    }) => void): this;
    on(event: 'time-lock' | 'time-unlock' | 'timer-reset', listener: () => void): this;
    on(event: string, listener: (...args: unknown[]) => void): this;
    once(event: 'lock' | 'unlock' | 'all-clear', listener: () => void): this;
    once(event: 'wait', listener: ({ lock, release }: {
        lock: Promise<void>;
        release: Release;
    }) => void): this;
    once(event: 'time-lock' | 'time-unlock' | 'timer-reset', listener: () => void): this;
    once(event: string, listener: (...args: unknown[]) => void): this;
}

declare class LeetCode extends EventEmitter {
    /**
     * The credential this LeetCode instance is using.
     */
    credential: Credential$1;
    /**
     * The internal cache.
     */
    cache: Cache;
    /**
     * Used to ensure the LeetCode instance is initialized.
     */
    protected initialized: Promise<boolean>;
    /**
     * Rate limiter
     */
    limiter: RateLimiter;
    /**
     * If a credential is provided, the LeetCode API will be authenticated. Otherwise, it will be anonymous.
     * @param credential
     * @param cache
     */
    constructor(credential?: Credential$1 | null, cache?: Cache);
    /**
     * Get public profile of a user.
     * @param username
     * @returns
     *
     * ```javascript
     * const leetcode = new LeetCode();
     * const profile = await leetcode.user("jacoblincool");
     * ```
     */
    user(username: string): Promise<UserProfile>;
    /**
     * Get public contest info of a user.
     * @param username
     * @returns
     *
     */
    user_contest_info(username: string): Promise<UserContestInfo>;
    /**
     * Get recent submissions of a user. (max: 20 submissions)
     * @param username
     * @param limit
     * @returns
     *
     * ```javascript
     * const leetcode = new LeetCode();
     * const submissions = await leetcode.recent_user_submissions("jacoblincool");
     * ```
     */
    recent_user_submissions(username: string, limit?: number): Promise<UserSubmission[]>;
    /**
     * Get submissions of the credential user. Need to be authenticated.
     *
     * @returns
     *
     * ```javascript
     * const credential = new Credential();
     * await credential.init("SESSION");
     * const leetcode = new LeetCode(credential);
     * const submissions = await leetcode.submissions({ limit: 100, offset: 0 });
     * ```
     */
    submissions({ limit, offset, }?: {
        limit?: number;
        offset?: number;
        slug?: string;
    }): Promise<Submission[]>;
    private submissionsApi;
    /**
     * Get detail of a submission, including the code and percentiles.
     * Need to be authenticated.
     * @param id Submission ID
     * @returns
     * @deprecated
     *
     */
    submission(id: number): Promise<SubmissionDetail>;
    /**
     * Get a list of problems by tags and difficulty.
     * @param option
     * @param option.category
     * @param option.offset
     * @param option.limit
     * @param option.filters
     * @returns
     */
    problems({ category, offset, limit, filters, }?: QueryParams): Promise<ProblemList>;
    /**
     * Get information of a problem by its slug.
     * @param slug
     * @returns
     */
    problem(slug: string): Promise<Problem>;
    /**
     * Get daily challenge.
     * @returns
     *
     * @example
     * ```javascript
     * const leetcode = new LeetCode();
     * const daily = await leetcode.daily();
     * ```
     */
    daily(): Promise<DailyChallenge>;
    /**
     * Check the information of the credential owner.
     * @returns
     */
    whoami(): Promise<Whoami>;
    /**
     * Use GraphQL to query LeetCode API.
     * @param query
     * @returns
     */
    graphql(query: LeetCodeGraphQLQuery): Promise<LeetCodeGraphQLResponse>;
    emit(event: 'receive-graphql', res: Response): boolean;
    emit(event: 'update-csrf', credential: Credential$1): boolean;
    emit(event: string, ...args: unknown[]): boolean;
    on(event: 'receive-graphql', listener: (res: Response) => void): this;
    on(event: 'update-csrf', listener: (credential: Credential$1) => void): this;
    on(event: string, listener: (...args: unknown[]) => void): this;
    once(event: 'receive-graphql', listener: (res: Response) => void): this;
    once(event: 'update-csrf', listener: (credential: Credential$1) => void): this;
    once(event: string, listener: (...args: unknown[]) => void): this;
}

declare class Credential implements ICredential {
    /**
     * The authentication session.
     */
    session?: string;
    /**
     * The csrf token.
     */
    csrf?: string;
    constructor(data?: ICredential);
    /**
     * Init the credential with or without leetcode session cookie.
     * @param session
     * @returns
     */
    init(session?: string): Promise<this>;
}

declare class LeetCodeCN extends EventEmitter {
    /**
     * The credential this LeetCodeCN instance is using.
     */
    credential: Credential;
    /**
     * The internal cache.
     */
    cache: Cache;
    /**
     * Used to ensure the LeetCodeCN instance is initialized.
     */
    private initialized;
    /**
     * Rate limiter
     */
    limiter: RateLimiter;
    /**
     * If a credential is provided, the LeetCodeCN API will be authenticated. Otherwise, it will be anonymous.
     * @param credential
     * @param cache
     */
    constructor(credential?: Credential | null, cache?: Cache);
    /**
     * Get public profile of a user.
     * @param username
     * @returns
     *
     * ```javascript
     * const leetcode = new LeetCodeCN();
     * const profile = await leetcode.user("jacoblincool");
     * ```
     */
    user(username: string): Promise<UserResult>;
    /**
     * Use GraphQL to query LeetCodeCN API.
     * @param query
     * @param endpoint Maybe you want to use `/graphql/noj-go/` instead of `/graphql/`.
     * @returns
     */
    graphql(query: LeetCodeGraphQLQuery, endpoint?: string): Promise<LeetCodeGraphQLResponse>;
    emit(event: 'receive-graphql', res: Response): boolean;
    emit(event: 'update-csrf', credential: Credential): boolean;
    emit(event: string, ...args: unknown[]): boolean;
    on(event: 'receive-graphql', listener: (res: Response) => void): this;
    on(event: 'update-csrf', listener: (credential: Credential) => void): this;
    on(event: string, listener: (...args: unknown[]) => void): this;
    once(event: 'receive-graphql', listener: (res: Response) => void): this;
    once(event: 'update-csrf', listener: (credential: Credential) => void): this;
    once(event: string, listener: (...args: unknown[]) => void): this;
}

interface NumAcceptedQuestion {
    difficulty: string;
    count: number;
}
interface NumFailedQuestion {
    difficulty: string;
    count: number;
}
interface NumUntouchedQuestion {
    difficulty: string;
    count: number;
}
interface UserProfileUserQuestionProgress {
    numAcceptedQuestions: NumAcceptedQuestion[];
    numFailedQuestions: NumFailedQuestion[];
    numUntouchedQuestions: NumUntouchedQuestion[];
}
interface Medal {
    name: string;
    year: number;
    month: number;
    category: string;
}
interface Ranking {
    currentLocalRanking: number;
    currentGlobalRanking: number;
    currentRating: string;
    totalLocalUsers: number;
    totalGlobalUsers: number;
}
interface SocialAccount {
    provider: string;
    profileUrl: string;
}
interface Profile {
    userSlug: string;
    realName: string;
    aboutMe: string;
    userAvatar: string;
    location: string;
    gender: string;
    websites: unknown[];
    skillTags: string[];
    contestCount: number;
    asciiCode: string;
    medals: Medal[];
    ranking: Ranking;
    socialAccounts: SocialAccount[];
}
interface UserProfilePublicProfile {
    username: string;
    haveFollowed?: unknown;
    siteRanking: number;
    profile: Profile;
}
interface UserResult {
    userProfileUserQuestionProgress: UserProfileUserQuestionProgress;
    userProfilePublicProfile: UserProfilePublicProfile;
}

declare const BASE_URL = "https://leetcode.com";
declare const BASE_URL_CN = "https://leetcode.cn";
declare const USER_AGENT = "Mozilla/5.0 LeetCode API";
declare const PROBLEM_CATEGORIES: string[];

declare const fetcher: Fetcher;
declare const _fetch: (input: string | URL | Request, init?: RequestInit | undefined) => ReturnType<typeof fetch>;

declare class LeetCodeAdvanced extends LeetCode {
    problemProperties: ProblemFieldDetails[];
    uniquePropertyOfProblem: string;
    constructor(credential?: Credential$1 | null, cache?: Cache);
    setUniquePropertyOfProblem(property: string): void;
    setCustomProblemProperties(problemProperties: ProblemFieldDetails[]): void;
    /**
     * Checks if easter egg is already collected.
     * Need to be authenticated.
     * @returns boolean
     */
    isEasterEggCollected(): Promise<boolean>;
    /**
     * Collects easter egg if available.
     * Need to be authenticated.
     */
    collectEasterEgg(): Promise<boolean>;
    /**
     * Get all topic tags for each question with question frontend id as key
     * @returns
     */
    topicTags(): Promise<Record<string, string[]>>;
    /**
     * Get all company tags with their details.
     * For company wise question details, need to be authenticated and should be premium user.
     * @returns
     */
    companyTags(): Promise<CompanyTagDetail[]>;
    /**
     * Get question frontend id to company tags mapping.
     * Need to be authenticated and should be premium user
     * @returns
     */
    getQuestionIdCompanyTagsMapping(): Promise<Record<string, string[]>>;
    /**
     * Checkin to collect a coin
     * Need to be authenticated
     */
    checkIn(): Promise<boolean>;
    /**
     * Get recent submission of current user.
     * Need to be authenticated
     * @returns Submission
     * @returns null if there are no recent submissions
     */
    recentSubmission(): Promise<Submission | null>;
    /**
     * Get recent submission of a user by username
     * Need to be authenticated
     * @param username
     * @returns Submission
     * @returns null if there are no recent submissions
     */
    recentSubmissionOfUser(username: string): Promise<UserSubmission | null>;
    /**
     * Get no of total problems in leetcode right now.
     * @returns number
     */
    noOfProblems(): Promise<number>;
    /**
     * Get leetcode lists of the user
     * Need to be authenticated
     * @returns array of leetcode lists
     */
    getLists(): Promise<Array<List>>;
    /**
     * Get all questions of a leetcode list
     * Need to be authenticated
     * @param slug slug id of the leetcode list
     * @returns array of questions
     */
    getQuestionsOfList(slug: string): Promise<Array<QuestionOfList>>;
    getProblemTypes(): Promise<Record<string, string[]>>;
    getLeetcodeProblems(limit?: number, callbackFn?: ((problems: LeetcodeProblem[]) => void) | null): Promise<LeetcodeProblem[]>;
    private parseProblems;
    /**
     * Get list of detailed problems by tags and difficulty.
     * This will collect details according to the problemProperties configuration and this is slow.
     * @param option
     * @param option.category
     * @param option.offset
     * @param option.limit
     * @param option.filters
     * @returns DetailedProblem[]
     */
    detailedProblems({ category, offset, limit, filters, }?: QueryParams): Promise<DetailedProblem[]>;
    /**
     * Get problems with a particular property and requests are sent according to the configuration.
     * @param problemProperty
     * @param QueryParams
     * @returns DetailedProblem[]
     */
    problemsOfProperty(problemProperty: ProblemFieldDetails, { category, offset, limit, filters }?: QueryParams): Promise<DetailedProblem[]>;
    /**
     * Get title slug question number mapping for all leetcode questions
     * @returns Mapping
     */
    getTitleSlugQuestionNumberMapping(): Promise<Record<string, string>>;
    private combineProperties;
    private getProblemsQuery;
}

export { type AcSubmissionNum, type AllCompanyTags, type AllQuestionsCount, type Article, BASE_URL, BASE_URL_CN, type Badge, Cache, type CacheItem, type CacheTable, type ChallengeQuestion, type CodeDefinition, type CodeSnippet, type CompanyTagDetail, type CompanyTagStat, type Contest, type ContestInfo, type ContestRanking, type Contributions, Credential$1 as Credential, type DailyChallenge, type DetailedProblem, type EasterEggStatus, type ICredential, LeetCode, LeetCodeAdvanced, LeetCodeCN, type LeetCodeGraphQLQuery, type LeetCodeGraphQLResponse, type LeetcodeProblem, type LeetcodeSolution, type List, type MatchedUser, type MinimalCompanyTagDetail, Mutex, type NextChallengePair, type OfficialCompanyTagStats, type OfficialSolution, PROBLEM_CATEGORIES, type Problem, type ProblemDifficulty, type ProblemFieldDetails, type ProblemList, type Profile$1 as Profile, type QueryParams, type QuestionOfList, RateLimiter, type Release, type SimilarQuestion, type Stats, type Submission, type SubmissionDetail, type SubmissionStatus, type SubmissionsDump, type SubmitStats, type TopicTag, type TopicTagDetails, type TotalSubmissionNum, USER_AGENT, type UserContestInfo, type UserProfile, type UserSubmission, type Whoami, _fetch, cache, caches, LeetCode as default, _fetch as fetch, fetcher };
